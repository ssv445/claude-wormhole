import { createServer } from 'http';
import { closeSync, existsSync, rmSync } from 'fs';
import { writeFile, mkdir } from 'fs/promises';
import { parse } from 'url';
import { join, extname } from 'path';
import { randomBytes } from 'crypto';
import { execFileSync } from 'child_process';
import next from 'next';
import { WebSocketServer, WebSocket } from 'ws';

const dev = process.env.NODE_ENV !== 'production';
const hostname = '127.0.0.1';
const port = parseInt(process.env.PORT || '3100', 10);

// Resolve tmux path at startup so node-pty can find it
const TMUX_PATH = (() => {
  try {
    return execFileSync('which', ['tmux']).toString().trim();
  } catch {
    return 'tmux'; // fallback
  }
})();
console.log(`Using tmux at: ${TMUX_PATH}`);

const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

// Build version — generated by prebuild script, read at startup
const BUILD_VERSION = (() => {
  try {
    return JSON.parse(require('fs').readFileSync(join(__dirname, '..', 'build-version.json'), 'utf8')).v;
  } catch {
    try {
      return JSON.parse(require('fs').readFileSync(join(process.cwd(), 'build-version.json'), 'utf8')).v;
    } catch { return 'unknown'; }
  }
})();
console.log(`Build version: ${BUILD_VERSION}`);

const SESSION_NAME_RE = /^[a-zA-Z0-9_-]+$/;

app.prepare().then(() => {
  // Clean up temp files older than 30 days — sessions may resume after server restart,
  // so we can't delete everything. Only prune genuinely stale files.
  try {
    const attachRoot = '/tmp/wormhole-attach';
    if (existsSync(attachRoot)) {
      const thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
      const { readdirSync, statSync } = require('fs');
      for (const sessionDir of readdirSync(attachRoot)) {
        const dirPath = join(attachRoot, sessionDir);
        try {
          const stat = statSync(dirPath);
          if (stat.isDirectory() && stat.mtimeMs < thirtyDaysAgo) {
            rmSync(dirPath, { recursive: true, force: true });
          }
        } catch { /* ignore per-dir errors */ }
      }
    }
  } catch { /* ignore */ }

  const server = createServer((req, res) => {
    // Prevent iOS from HTTP-caching sw.js — stale SW causes PWA deadlock
    if (req.url === '/sw.js') {
      res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    }
    const parsedUrl = parse(req.url!, true);
    handle(req, res, parsedUrl);
  });

  const wss = new WebSocketServer({ noServer: true });

  server.on('upgrade', (req, socket, head) => {
    const { pathname, query } = parse(req.url!, true);

    if (pathname === '/api/terminal') {
      const session = query.session as string;
      if (!session || !SESSION_NAME_RE.test(session)) {
        socket.write('HTTP/1.1 400 Bad Request\r\n\r\n');
        socket.destroy();
        return;
      }

      wss.handleUpgrade(req, socket, head, (ws) => {
        wss.emit('connection', ws, req, session);
      });
    } else {
      socket.destroy();
    }
  });

  wss.on('connection', (ws: WebSocket, _req: unknown, session: string) => {
    // Check if tmux session exists before spawning PTY
    try {
      execFileSync(TMUX_PATH, ['has-session', '-t', session], { stdio: 'ignore' });
    } catch (err) {
      console.warn(`Rejected connection to non-existent session: ${session}`);
      ws.send(`\x1b[31mError: tmux session "${session}" does not exist.\x1b[0m\r\n`);
      ws.send(`\x1b[33mRun "tmux ls" to see available sessions.\x1b[0m\r\n`);
      ws.close(1008, `Session not found: ${session}`);
      return;
    }

    // Lazy-require node-pty so Next.js webpack doesn't try to bundle it
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const pty = require('node-pty');

    // Build env with proper PATH for homebrew (Apple Silicon + Intel Mac)
    // Explicit type preserves the string index signature from process.env
    const env: Record<string, string | undefined> = { ...process.env, TERM: 'xterm-256color' };
    for (const dir of ['/opt/homebrew/bin', '/usr/local/bin']) {
      if (existsSync(dir) && !env.PATH?.includes(dir)) {
        env.PATH = `${dir}:${env.PATH}`;
      }
    }

    let ptyProcess: ReturnType<typeof pty.spawn>;
    // node-pty 1.1.0 leaks the first ptmx fd it opens (the one before _fd).
    // Track it so we can close it manually during cleanup.
    let leakedMasterFd: number | null = null;
    try {
      ptyProcess = pty.spawn(TMUX_PATH, ['-u', 'attach-session', '-t', session], {
        name: 'xterm-256color',
        cols: 80,
        rows: 24,
        cwd: process.env.HOME,
        env,
      });
      // node-pty opens ptmx twice: fd N (leaked) and fd N+1 (tracked as _fd)
      if (typeof ptyProcess._fd === 'number') {
        leakedMasterFd = ptyProcess._fd - 1;
      }
    } catch (err) {
      console.error('Failed to spawn PTY:', err);
      ws.close(1011, 'PTY spawn failed');
      return;
    }

    console.log(`PTY spawned for session: ${session}, pid: ${ptyProcess.pid}`);

    // Send build version to client for cache-busting check
    ws.send(JSON.stringify({ type: 'version', v: BUILD_VERSION }));

    // Heartbeat — detect dead connections (iOS backgrounding kills WS silently)
    let isAlive = true;
    ws.on('pong', () => { isAlive = true; });
    const heartbeat = setInterval(() => {
      if (!isAlive) { ws.terminate(); return; }
      isAlive = false;
      ws.ping();
    }, 30_000);

    // PTY → WebSocket
    ptyProcess.onData((data: string) => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(data);
      }
    });

    // Track cleanup state to avoid double-destroy
    let cleaned = false;
    const cleanup = () => {
      if (cleaned) return;
      cleaned = true;
      clearInterval(heartbeat);
      try { ptyProcess.kill(); } catch { /* already dead */ }
      try { ptyProcess.destroy(); } catch { /* already dead */ }
      // Close the leaked master ptmx fd that node-pty never cleans up
      let closedLeakedFd = false;
      if (leakedMasterFd !== null) {
        try {
          closeSync(leakedMasterFd);
          closedLeakedFd = true;
        } catch { /* already closed */ }
        leakedMasterFd = null;
      }
      // Don't delete temp files here — iOS backgrounding kills WS, but the
      // file path is already in the PTY input. Claude Code needs it after reconnect.
      // Cleanup happens at server startup instead.
      if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
        ws.close();
      }
      console.log(`Cleaned up PTY for session: ${session}, closedLeakedFd: ${closedLeakedFd}`);
    };

    ptyProcess.onExit(({ exitCode }: { exitCode: number }) => {
      console.log(`PTY exited for session: ${session}, code: ${exitCode}`);
      cleanup();
    });

    // WebSocket → PTY
    ws.on('message', (msg: Buffer | string) => {
      const str = msg.toString();

      // Check for JSON control messages
      if (str.startsWith('{')) {
        try {
          const parsed = JSON.parse(str);
          if (parsed.type === 'resize' && parsed.cols && parsed.rows) {
            ptyProcess.resize(parsed.cols, parsed.rows);
            return;
          }

          if (parsed.type === 'file_attach') {
            // Async handler — don't block the event loop for large files
            (async () => {
              try {
                const { name, data } = parsed;
                // Server-side size cap: ~10MB decoded (base64 is ~33% larger)
                const MAX_BASE64_BYTES = 14 * 1024 * 1024;
                if (!name || !data || typeof name !== 'string' || typeof data !== 'string' || data.length > MAX_BASE64_BYTES) {
                  ws.send(JSON.stringify({ type: 'file_error', message: 'Missing, empty, or oversized payload (max 10MB)' }));
                  return;
                }
                // Sanitize extension — extname handles dotfiles correctly (.bashrc → '')
                const rawExt = extname(name).slice(1).replace(/[^a-zA-Z0-9]/g, '');
                const ext = rawExt ? '.' + rawExt : '';
                const safeName = randomBytes(8).toString('hex') + ext;
                const dir = join('/tmp', 'wormhole-attach', session);
                await mkdir(dir, { recursive: true });
                const filePath = join(dir, safeName);
                await writeFile(filePath, Buffer.from(data, 'base64'));
                // Type the path directly into the PTY — avoids client round-trip
                // which can fail if the WS connection drops (iOS heartbeat timeout).
                // Space separates from existing text, @ tells Claude Code to reference the file.
                ptyProcess.write(` @${filePath} `);
                ws.send(JSON.stringify({ type: 'file_saved', path: filePath, originalName: name }));
              } catch (err) {
                const message = err instanceof Error ? err.message : 'File save failed';
                ws.send(JSON.stringify({ type: 'file_error', message }));
              }
            })();
            return;
          }

          if (parsed.type === 'debug') {
            console.log(`[DEBUG ${session}]`, parsed.message);
            return;
          }
        } catch {
          // Not JSON, treat as terminal input
        }
      }

      ptyProcess.write(str);
    });

    ws.on('close', cleanup);
    ws.on('error', (err) => {
      console.error(`WebSocket error for session: ${session}:`, err.message);
      cleanup();
    });
  });

  server.listen(port, hostname, () => {
    console.log(`> claude-wormhole ready on http://${hostname}:${port}`);
  });
});
